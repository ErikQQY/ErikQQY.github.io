[{"title":"SDG 10th biweekly report","url":"/2024/09/15/24-sdg-10th/","content":"Review of the past two weeksIn the last two weeks, my work can be summarized as two parts: Enabling automatic differentiation for implemented SPIRK methods and refactor the new Lobatto and Radau methods in BoundaryValueDiffEq.jl.\n\nFinally the automatic differentiation part of the implemented COLDAE solver is done, now we can use ForwardDiff.jl to obtain more precise and accurate numerical results of the boundary value differential-algebraic equations. Also, the implemented COLDAE solvers still didn’t have a proper name, so we can just call it SPIRK(Selective Projected Implicit Runge-Kutta) methods. Similar to what we have done for MIRK and FIRK methods, sparse jacobian for SPIRK methods is also done to support symbolic sparsity detection. Now the only work left is to optimize the code and refactor it to the SciML style like standard MIRK and FIRK methods.\n\nThe Lobatto and Radau methods in BoundaryValueDiffEq.jl are refactored to a more concise and efficient style. For details of the progress, please check the PR Refactor FIRK methods and the splitting into subpackages to improve precompile workload is already done, just need to bump the version and file the PR.\n\n\nMore TODOs:\nRefactor the implemented solvers to be compatible with the SciML style, and simplify the internal of Lobatto DAE solvers.\n\nComplete the splitting of BoundaryValueDiffEq.jl into subpackages.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 11st biweekly report","url":"/2024/09/30/24-sdg-11st/","content":"Review of the past two weeksIn the last two weeks, my work can be summarized as two parts: wrapping up the final pull request and prepare the benchmarking for BoundaryValueDiffEq.jl.\n\nFinally the wrapped and refactored all the Ascher solvers for boundary value differential-algebraic equations, and the detailed programs can be checked on github now: Add BVDE solvers and the PR is already integrated into the BoundaryValueDiffEq.jl to make it self a standalone subpackage like what we have done in OrdinaryDiffEq.jl. What’s left to finih this work is to polish the current implementation and make it more robust and performant, find more tests cases to prove its reliabilities, reduce the memory allocations and overhead etc.\n\nThe BoundaryValueDiffEq.jl splitting part is also almsot done by now, just need to figure out how to properly handle the extension algorithms from ODEInterface.jl and make the core package to be registered. The detailed splitting process can be checked in following several PRs: Splitting MIRK methods into subpackage, Splitting FIRK methods into subpackage, Splitting Shooting methods into subpackage and Core subpackage for BoundaryValueDiffEq\n\nAdded more simple solvers and utils for SimpleBoundaryValueDiffEq.jl to prepare the benchmarking stuff: Add SimpleShooting method\n\n\nMore TODOs:\nRefactor the implemented solvers to be compatible with the SciML style, and simplify the internal of Ascher DAE solvers.\n\nComplete the splitting and update the benchmarking scripts and figure for BVPs.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 12nd biweekly report","url":"/2024/10/15/24-sdg-12nd/","content":"Review of the past two weeksIn the last two weeks, my work can be summarized as two parts: wrapping up the final pull request and done the benchmarking for BoundaryValueDiffEq.jl.\n\nFinally the BVDAE PR is ready for reviewing now. What’s left to finih this work is to polish the current implementation and make it more robust and performant, talking with Chris and Avik, and find more tests cases (over-constraints and under constraints BVDAEs) to prove its reliabilities, reduce the memory allocations and overhead etc.\n\nThe upgrade for the BVP benchmarking is also done now, detailed workround can be check in several PR: Update linear BVP benchmarking, Remove unsuccessful solvings in linear BVP benchmarks and Reject non successful retcodes in BVP benchmarks. There are still more benchmarks can be added to demenstrate the performance of solvers in BoundaryValueDiffEq.jl, possibly the orbital dynamics benchmarks can be updated now.\n\nImplemented the COLDAE wrappers for ODEInterface.jl, it’s different with what I did few months ago, which was just a WIP PR. Now the wrappers is fully functioning now, we can use it by calling coldae in ODEInterface.jl just like colnew and bvpsol, to try out, please refer to my fork of this packge: ErikQQY’s ODEInterface.jl\n\n\nMore TODOs:\nRefactor the implemented solvers to be compatible with the SciML style, and simplify the internal of Ascher DAE solvers.\n\nReview the PR with Chris and Avik, get this PR merged as soon as possible!\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 13rd biweekly report","url":"/2024/10/30/24-sdg-13rd/","content":"Review of the past two weeksIn the last two weeks, my work can be summarized as two parts: wrapping up the final pull request and done the benchmarking for BoundaryValueDiffEq.jl.\n\nThe BoundaryValueDiffEq.jl splitting work is finally done, past two weeks mainly focused on some extra trivial works on ensuring the parent packages and subpackages are using the correct packages and the file paths are not using relative paths afterwards.\n\nFinally the BVDAE solvers PR was merged 🎉🎉🎉🎉🎉!. What’s left to continue polishing in this work is to standardize the interface and refactor the internal of Ascher solver, some future work will be tracked in this isue: Some issues with BVDAE solvers in BoundaryValueDiffEq.jl, mainly about finding more tests cases (over-constraints and under constraints BVDAEs) to prove its reliabilities, reduce the memory allocations and overhead etc.\n\nRerefactored the previous work on MIRKN methods for SecondOrderBVProblem, and the convergence tests are passing now for the implemented MIRKN4 and MIRKN6 methods, but when I was constructing a second order BVP, the interface of SecondOrderBVProblem did not accept 5 arguments analytical solution specified, I need to make the changes for alowing this.\n\n\nMore TODOs:\nRefactor the implemented solvers to be compatible with the SciML style, and simplify the internal of Ascher DAE solvers.\n\nFinish the MIRKN PR and get this PR merged as soon as possible!\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 14th biweekly report","url":"/2024/11/15/24-sdg-14th/","content":"Review of the past two weeksIn the last two weeks, my work can be summarized as two parts: Refactoring the BoundaryValueDiffEq.jl to use NonlinearSolveFirstOrder and fix the new CI.\n\nWith the v4 version of NonlinearSolve.jl released, there is no need to introduce the whole NonlinearSolve.jl into BoundaryValueDiffEq.jl, we can just use the first order emthods like NewtonRaphson, LevenbergMarquardt and TrustRegion etc. So with PR Use NonlinearSolveFirstOrder subpackage and use new CI, we can just use the subpackage now and reduce the overhead of using the whole NonlinearSolve package.\n\nAlso in the PR Use NonlinearSolveFirstOrder subpackage and use new CI, the CI is now configured to develop the newest version of each subpackage and execute the tests, which would be quite convenient to directly test some breaking changes.\n\nIn the process of imlementing PR Use NonlinearSolveFirstOrder subpackage and use new CI, there are several issues complaining about the failing precompiling of BoundaryValueDiffEq.jl, inluding Nested_nlsolve in RadauIIa7 issue, Deprecated use of NonlinearSolve.LineSearch, BoundaryValueDiffEq does not precompile on Windows 11\n\nWith the BVDAE sovlers merged, I also found several issues for this solver when I am configuring the new CI, mainly about the cache expansion of Ascher methods, and several patches have been sent in the same PR Use NonlinearSolveFirstOrder subpackage and use new CI.\n\n\nMore TODOs:\nWith the NonlinearSolve v4 are now using DifferentiationInterface.jl, BoundaryValueDiffEq.jl are now should use DifferentiationInterface.jl and unify the whole ecosystem。\n\nOpened an issue to sort several things out in the implementation of infinite final time BVP solver, and will start on this when the above feature is done.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 15th biweekly report","url":"/2024/11/30/24-sdg-15th/","content":"Review of the past two weeksIn the last two weeks, my work can be summarized as two parts: Refactoring the BoundaryValueDiffEq.jl to use DifferentiationInterface and make the code more autodiff compatible.\n\nWith the DifferentiationInterface.jl are growing more mature and NonlinearSolve.jl has replaced SparseDiffTools.jl to DI for supporting sparse jacobian exploitation, we should keep packages in SciML universe using same API, and by changing to DI, we can have more options on using more AD backend, so recent two weaks were refactoring the current stack from SparseDiffTools.jl to DifferentiationInterface.jl+SparseMatrixColorings.jl+SparseConnectivityTracer.jl, detailed PR can be check in Use DifferentiationInterface for the Jacobian.\n\nWhile implementing the above refactoring, several bugs have beeen found in the upstream packages in DifferentiationInteface.jl and SparseConnectivityTracer.jl, mainly about BoundaryValueDiffEq.jl need to cover many edge cases while DI and SDT have strict type management, but all of them are figured out during communication with Guillaume and Adrian(thank you for your patient guide and quick response!), detailed issue and PR can be checked in prepare_jacobian error for OOP function with type unspecified output, Complex number support, Relax type annotations in sparse prep\n\nStart implementing infinite final time boundary value problems solver, check out how BVPSUITE have managed to done it.\n\n\nMore TODOs:\nComplete the PR for refactoring BoundaryValueDiffEq.jl from SparseDiffTools.jl to DifferentiationInterface.jl\n\nStart working on the implementation of infinite final time BVP solver, and will start on this when the above feature is done.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 16th biweekly report","url":"/2024/12/15/24-sdg-16th/","content":"Review of the past two weeksIn the last two weeks, my work can be summarized as two parts: Refactoring the boundary conditions convention in BoundaryValueDiffEq.jl and make the code more autodiff compatible.\n\nThis is kind of old problems with BoundaryValueDiffEq.jl, detailed information can be checked in numerous issues: README example should use interpolation instead of indexing, Indexing in boundary conditions, and previous various attempt on resolving this: Boundary conditions should always use solution object. But finally got some time for this issue now: Boundary conditions should always use solution object and Use solution object in all solvers, the basic idea is to change the previous bc convention from indexing based:\n\nfunction bc!(residual, u, p, t)    residual[1] = u[:, end÷2][1] + pi / 2    residual[2] = u[:, end][1] - pi / 2end\n\nto interpolation based:\nfunction bc!(residual, u, p, t)    residual[1] = u(pi/4)[1] + pi / 2    residual[2] = u(pi/2)[1] - pi / 2end\n\nThe previous methods are overly focused on changing the inner value of a solution, which is difficult since there would be dual numbers in the solution, the current workaround is to changing the solution in the loss function, but in the Jacobian function building process, we just built a new one. Interesting that it does accelerate the solving process:\n# Current workaroundjulia&gt; @benchmark sol = solve(prob, MIRK4(), dt = 0.05)BenchmarkTools.Trial: 9976 samples with 1 evaluation. Range (min … max):  398.833 μs …  21.430 ms  ┊ GC (min … max):  0.00% … 97.59% Time  (median):     434.625 μs               ┊ GC (median):     0.00% Time  (mean ± σ):   500.182 μs ± 563.331 μs  ┊ GC (mean ± σ):  12.65% ± 10.75%  █▄                                                            ▁  ██▇▅▄▃▁▁▁▃▁▁▁▃▁▃▁▁▁▁▁▁▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▅▃▆▇ █  399 μs        Histogram: log(frequency) by time       4.41 ms &lt; Memory estimate: 1.08 MiB, allocs estimate: 24342.\n\n# Master branchjulia&gt; @benchmark sol = solve(prob, MIRK4(), dt = 0.05)BenchmarkTools.Trial: 9520 samples with 1 evaluation. Range (min … max):  411.166 μs …  15.173 ms  ┊ GC (min … max):  0.00% … 96.72% Time  (median):     459.167 μs               ┊ GC (median):     0.00% Time  (mean ± σ):   524.214 μs ± 598.530 μs  ┊ GC (mean ± σ):  11.43% ±  9.61%  █▂                                                            ▁  ██▄▃▃▁▃▄▄▁▃▁▁▁▄▁▁▁▁▁▁▁▁▃▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃▃▁▃▁▁▃▁▁▁▃▁▃▁▁▃▁▁▁▃▆ █  411 μs        Histogram: log(frequency) by time       5.38 ms &lt; Memory estimate: 1.03 MiB, allocs estimate: 23762.\n\n\nWhile implementing changing to DifferentiationInterface.jl PR, another bug from NonlinearSolve.jl has been spotted: Access to undefined reference when solving problems with Dual of BigFloat and fixed by generalizing the nonlinear solving with dual number to every package: refactor: Move dual nonlinear solving to NonlinearSolveBase\n\nImplementing infinite final time boundary value problems solver, check out how BVPSUITE have managed to done it.\n\n\nMore TODOs:\nComplete the PR for refactoring BoundaryValueDiffEq.jl from SparseDiffTools.jl to DifferentiationInterface.jl\n\nStart working on the implementation of infinite final time BVP solver, and will start on this when the above feature is done.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 18th biweekly report","url":"/2025/01/15/24-sdg-18th/","content":"Review of the past two weeksIn the last two weeks, my work can be summarized as two parts: Continuing the integration of DifferentiationInterface.jl in BoundaryValueDiffEq.jl and add more documentations.\n\nThe last several weeks on integrating DifferentiationInterface.jl to BoundaryValueDiffEq.jl is almost done in PR Use DifferentiationInterface for the jacobian, feat: access overloaded inputs from preparation result.\n\nContinued the revamp of documentation, including the individual documentatoin n DiffEqDocs.jl one, details can be checked on corresponding pull request: Add documentations and Revamp BVP docs for new features.\n\nImplemented an interface package BVPInterface.jl for porting Fortran BVP solvers into SciML universe, now it ports BVPM2, BVPSOL, COLSYS, COLNEW, COLDAE, and COLMOD, more solvers will be implemented in the near future.\n\n\nMore TODOs:\nComplete the PR for refactoring BoundaryValueDiffEq.jl from SparseDiffTools.jl to DifferentiationInterface.jl\n\nStart working on the implementation of infinite final time BVP solver, and will start on this when the above feature is done.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 17th biweekly report","url":"/2024/12/30/24-sdg-17th/","content":"Review of the past two weeksIn the last two weeks, my work is minly focused on the integration of DifferentiationInterface.jl, detailed progress can be checked on Use DifferentiationInterface for the jacobian. And while Christmas and new year is around the corner, I need to handling some other stuff.\nMore TODOs:\nComplete the PR for refactoring BoundaryValueDiffEq.jl from SparseDiffTools.jl to DifferentiationInterface.jl\n\nStart working on the implementation of infinite final time BVP solver, and will start on this when the above feature is done.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 1st biweekly report","url":"/2024/04/30/24-sdg-1st/","content":"It is really exciting that the SDG proposal has been approved, I am really honored to get this funding to help me continue the BVP works. To make sure the project going on the right track with appropriate speed, I will record biweekly progress in this blog during the whole SDG project period.\nReview of the past two weeksIn the first two weeks, I completed the basic structure of the whole COLDAE method, implemented the whole collocation method in Julia. The rewriting is relatively easy, the original COLDAE program has a well-documented explanation of each subroutine and thanks to previous GSoC experience, I can smoothly read the FORTRAN program and implement our own in Julia. After the basic structure is set up, the first thing is to ensure the correctness of the implemented method, e.g. the basic computing flow, workspace initialization, collocation equations setup and solving, nonlinear iterations, error check and mesh refinement etc. For now, to ensure the correctness of the implemented solver, I am using a simple BVDAE example, which can be found on the COLDAE paper: Collocation Software for Boundary Value Differential-Algebraic Equations. I used example problem 2 as the test case, which is a nonlinear, semi-explicit DAE of index at most 2:\n\nwith boundary conditions:\n\nWe set the parametric functions as . So this BVDAE would have two isolated solutions:\n\nWhen we set , we obtain ,  and . This linearized problem around this solution has index 1.\n\nWhen we set , we can obtain ,  and . This variational problem around this solution has index 2.\n\n\nwith intensive testing and rewriting, the implemented method finally has a correct return for this testing problem.\nfunction fsub(x,z,y,f)    e = 2.7    f[1] = (1+z[2]-sin(x))*y[1]+cos(x)    f[2] = cos(x)    f[3] = y[1]    f[4] = (z[1]-sin(x))*(y[1]-e^x) # algebraic equationendfunction dfsub(x,z,y,df)    e = 2.7    df[1,1] = 0 # df_1/df1    df[1,2] = y[1] # df_1/df1'    df[1,3] = 0 # df_1/df2    df[1,4] = 1+z[2]-sin(x) # df_1/df2    df[2,1] = 0 # df_2/df1    df[2,2] = 0 # df_2/df1'    df[2,3] = 0    # df_2/df2    df[2,4] = 0 # df_1/df2        df[3,1] = 0 # df_1/df2    df[3,2] = 0 # df_1/df2    df[3,3] = 0 # df_1/df2    df[3,4] = 1 # df_1/df2        df[4,1] = y[1]-e^x # df_1/df2    df[4,2] = 0 # df_1/df2    df[4,3] = 0 # df_1/df2    df[4,4] = z[1]-sin(x) # df_1/df2endfunction gsub(i,z,g)    if i == 1        g[1] = z[1]        return g    elseif i == 2        g[1] = z[3] - 1        return g    elseif i == 3        g[1] = z[2] - sin(1.0)        return g    endendfunction dgsub(i,z,dg)    if i == 1        dg[1]=1 # dg_1/df1        dg[2]=0 # dg_1/df1'        dg[3]=0 # dg_1/df1'    elseif i == 2        dg[1]=0 # dg_2/df1        dg[2]=0 # dg_2/df1'        dg[3]=1 # dg_2/df1'    elseif i == 3        dg[1]=0 # dg_2/df1        dg[2]=1 # dg_2/df1'        dg[3]=0 # dg_2/df1'    endend\n\n(this syntax is only temporal, I will change them to the regular SciML style we are familiar with)\nThe output from my implementation(from Windows terminal):\n\nAlthough for now the implementation only covers a part of the whole functionality and doesn’t follow the programming standards(so many parts need to be simplified, e.g. so many inconvenient @goto and if...else statements, nonstandard variables passing, ti etc.), but it still demonstrates the capability of the targeting BVDAE solver.\nIn the following two weeks, there are a few TODOs:\n\nUse other BVDAE examples to continue the testing and hopefully cover all the problem types e.g. purely implicit BVDAE with index 1 etc.\nRefactor the implemented solvers to be more readable and concise.\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 2nd biweekly report","url":"/2024/05/15/24-sdg-2nd/","content":"Review of the past two weeksAfter the last two weeks of extensive work on COLDAE, it is finally working for a test example now. During these two weeks, I started the refactorization for the implemented solvers and obtained some progress:\n\nMove the almost block diagonal matrix factorization and solving into a new package AlmostBlockDiagonals.jl, which contains the PLU factorization and solving algorithms for the almost block diagonal matrix in SOLVEBLOK. Almost block diagonal matrix is a common structure in the underlying geometry of the discretized differential equations. For now, the basic structure of AlmostBlockDiagonals.jl is done and the first several versions have been released. The package is registered in the General registry, so you can install it by ]add AlmostBlockDiagonals. I will continue to improve the package and add more features in the future.\n\nRemoved the extensive usage of @label and @goto in the collocation methods, which really improved the readability of the code.\n\nRefactored all of the programs in the solver, but still needed more work to make the solver accord with the SciML style.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 3rd biweekly report","url":"/2024/05/30/24-sdg-3rd/","content":"Review of the past two weeksIn the last two weeks, the main work has focused on the refactoring of the implemented solvers, some progress can be summarized as follows:\n\nMake the API of implemented solvers more consistent and easy to use. For example, the most block diagonal matrices solving in setting up collocation matrix is now simply AlmostBlockDiagonals.factor and AlmostBlockDiagonals.substitution.\n\nThe matrices and vector indices are no longer the awkward integer-to-integer slicing but with a more intuitive and easy-to-read style.\n\nThe user interface has been changed to user friendly style which we are already very familiar with:\n\n\nglobal function fsub(du, u, t)    e = 2.7    du[1] = (1+u[2]-sin(t))*u[4] + cos(t)    du[2] = cos(t)    du[3] = u[4]    du[4] = (u[1]-sin(t))*(u[4]-e^t)endglobal function dfsub(df, u, t)    e = 2.7    df[1,1] = 0    df[1,2] = u[4]    df[1,3] = 0    df[1,4] = 1+u[2]-sin(t)    df[2,1] = 0    df[2,2] = 0    df[2,3] = 0    df[2,4] = 0        df[3,1] = 0    df[3,2] = 0    df[3,3] = 0    df[3,4] = 1        df[4,1] = u[4]-e^t    df[4,2] = 0    df[4,3] = 0    df[4,4] = u[1]-sin(t)endglobal function gsub(res, u, p, t)    res[1] = u[1] # t==0.0    res[2] = u[3] - 1 # t == 0.0    res[3] = u[2] - sin(1.0) # t == 1.0endglobal function dgsub(dres, u, p, t)    dres[1] = [1.0, 0.0, 0.0] #corresponding dg    dres[2] = [0.0, 0.0, 1.0]    dres[3] = [0.0, 1.0, 0.0]end\n(The boundary conditions and derivative of boundary conditions need further modification to be able to directly plug into the existing SciMLBase.jl and DiffEqBase.jl).\nThe overall computing flow can be summarized as follows:\n\nMore TODOs:\nAccording to the above computing flow graph, refactor the whole solving process and utilize the init-cache-solve-cache process in MIRK solvers.\n\nContinue to refactor the solver, especially the collocation equations setting up part.\n\nTry the implemented solver on different examples and see if there are any improvements we need to complete.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 4th biweekly report","url":"/2024/06/15/24-sdg-4th/","content":"Review of the past two weeksIn the last two weeks, the main work still focuses on the refactorization and external solver API implementation, some progress can be summarized as follows:\n\nMatrices and vector indices refactoring still have some left which are quite tricky to continue, the main refactoring is located in the subroutine of collocation equations setup, e.g. the global BVP matrices, the matrices represent solutions and their derivative, which is the most important part of the solver.\n\nContinue previous work on the implementation of extension from ODEInterface.jl, mainly about interfacing the COLNEW solver into BoundaryValueDiffEq.jl, detailed progress can be checked here: COLNEW supports multi-points BVP for now there are testing errors about MultipleShooting methods, but it will be addressed soon.\n\nThe initial version of COLDAE in ODEInterface.jl, it would be great to have COLDAE interface in ODEInterface.jl, which would provide us more intuitive and easy-to-use API to compare and benchmark our implementation, detailed progress can be checked here: Add COLDAE solver.\n\n\nMore TODOs:\nContinue the current pull request and finish these features as soon as possible.\n\nRefactor the nonlinear iteration process and utilize the init-cache-solve-cache process in MIRK solvers.\n\nContinue to refactor the solver, especially the collocation equations setting up part.\n\nTry the implemented solver on different examples and see if there are any improvements we need to complete.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 5th biweekly report","url":"/2024/06/30/24-sdg-5th/","content":"Review of the past two weeksIn the last two weeks, the main work focused on developing new solvers for different kinds of BVPs, improving the testing coverage of the implemented solvers, and fixing a lot of possible bugs, some progress can be summarized as follows:\n\nImplemented more BVDAE testing problems from BVDAE-oriented research papers, linear and nonlinear, index-1 and index-2 problems, during the comparing process, I found there are some differences from the output of COLDAE and my implementation, mainly about the collocation system setup and solving part, which is the most important part of the solver, so I need to put more time on polishing this.\n\nImplemented MIRKN methods for SecondOrderBVProblem, the main nonlinear system-solving process is done, and are getting a correct result now, but there are still some issues with the sparsity detection and automatic differentiation stuff that need to be dug in.\n\n\nFor example, as for second-order boundary value problem example:\n\nwith boundary conditions:\n\nTo utilize the MIRKN method to solve this second-order system with BoundaryValueDiffEq.jl, we only need to follow what we do when solving first-order BVP system with MIRK methods:\nfunction test(ddu, du, u, p, t)    ϵ = 0.1    ddu[1] = u[2]    ddu[2] = (-u[1]*du[2] - u[3]*du[3])/ϵ    ddu[3] = (du[1]*u[3] - u[1]*du[3])/ϵendfunction bc(res, du, u, p, t)    res[1] = u[1][1]    res[2] = u[end][1]    res[3] = u[1][3] + 1    res[4] = u[end][3] - 1    res[5] = du[1][1]    res[6] = du[end][1]endu0 = [1.0, 1.0, 1.0]tspan = (0.0, 1.0)prob = SecondOrderBVProblem(test, bc, u0, tspan)sol=solve(prob, MIRKN4(), dt=0.01)\n\nThe solution from BoundaryValueDiffEq.jl would be:\n\nMore TODOs:\nFix the sparsity detection and automatic differentiation issues and send the current implementations of MIRKN as soon as possible.\n\nAccording to the different example problems find possible bugs in the COLDAE implementation and see if there are any improvements we need to complete.\n\nContinue to refactor the solver, especially the collocation equations setting up part.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 6th biweekly report","url":"/2024/07/15/24-sdg-6th/","content":"Review of the past two weeksIn the last two weeks, I attended the JuliaCon! It was so great to finally meet the amazing Julia community and talk with everyone! I focused on the refactorization and sent a PR for the Monotonic-Implicit Runge-Kutta-Nystrom methods, and some progress can be summarized as follows:\n\nImplemented MIRKN methods for SecondOrderBVProblem, the main nonlinear system-solving process is done, and are getting a correct result now, but there are still some issues with the sparsity detection and automatic differentiation stuff that need to be dug in. The detailed pull request can be checked on GitHub: Add MIRKN methods, it is still a Working-In-Progress, need further development to get this done.\n\nTalked with Chris during the JuliaCon, the main focus should be first on the Lobatto methods and Radau methods for BVP, which is originally planned to be implemented by Axel Larsson, the basic working flow is almost done, but the CI are still not passing, I need to help get this PR get merged first to continue the COLDAE part(with Lobatto tableaus, what’s more is the collocation equations for the BVDAE and then we can have our collocation methods for boundary value differential-algebraic equations)\n\nFixed the existing issues with BoundaryValueDiffEQ.jl, such as fixing CI failing, COLNEW supports multi-points BVP etc, detail PR can be checked on the GitHub.\n\n\nMore TODOs:\nGet the Lobatto methods and Radau methods PR merged as soon as possible.\n\nThe solution indexing methods in boundary conditions for MIRK methods and Shooting methods are quite different in BoundaryValueDiffEq.jl, for example, as for Shooting methods, we can use u(t1) to get the specific component of the solution at the specific time, but for the MIRK methods, we can’t do that, which is quite cumbersome, need to unify this.\n\nFix the sparsity detection and automatic differentiation issues and get that PR merged.\n\nAccording to the different example problems find possible bugs in the COLDAE implementation and see if there are any improvements we need to complete.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 7th biweekly report","url":"/2024/07/30/24-sdg-7th/","content":"Review of the past two weeksIn the last two weeks, my work can be summarized as two parts: Implementing the basic structure of COLDAE from scratch and maintaining the BoundaryValueDiffEq.jl package.\n\nWith the previously translated COLDAE solver, it is easy to see the structure of COLDAE and the collocation equations, during the past two weeks, I utilized the collocation equations setup subroutine and solution approximating subroutine to construct a simple version of COLDAE solver from scratch, for example, the similar routine like what we did in MIKR methods, construct nonlinear problems using collocation equations and solve the nonlinear system. By testing on the example test problem, the discrete solution is converging now.\n\nFixed the existing issues with BoundaryValueDiffEq.jl, such as Fix benchmarks CI, Fix non-adaptive interpolation, Fix StaticArrays support for MIRK methods and ongoing Fix support for BigFloat u0.\n\nThe Lobatto and Radau methods for BVP are almost done and CIs are passing now, still need the BigFloat support to be configured to push this forward.\n\n\nMore TODOs:\nContinue the polishing of the simple COLDAE implementation and test the solver on more example problems to see if there are any bugs or improvements needed. Add the error estimate part and mesh refinement part as well to support more features.\n\nContinuing the BigFloat support and getting the Lobatto and Radau solvers PR get merged as soon as possible.\n\nFix the interpolations for MIRK methods, related issues are MIRK4 interpolation bugs.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 8th biweekly report","url":"/2024/08/15/24-sdg-8th/","content":"Review of the past two weeksIn the last two weeks, my work can be summarized as two parts: Refactoring the implemented COLDAE solver to make it compatible with the SciML style and maintaining the BoundaryValueDiffEq.jl package.\n\nWith the previously translated COLDAE solver, it is easy to see the structure of COLDAE and the collocation equations, during the past two weeks, while the discrete solution from the solver is converging now, I refactored the implemented solver, such as standardizing the function name, cache initialization and modifying etc, now what’s left is to plug in the ForwardDiff automatic differentiation part and then all is done.\n\nUpgrade support for the RecursiveArrayTools.jl and help the centralized reusable workflow CI. The semantics for defining a BVP are now much different from before:\n\n\nusing BoundaryValueDiffEqtspan = (0.0, pi / 2)function simplependulum!(du, u, p, t)    θ = u[1]    dθ = u[2]    du[1] = dθ    du[2] = -9.81 * sin(θ)endfunction bc!(residual, u, p, t)    residual[1] = u[:, end ÷ 2][1] + pi / 2    residual[2] = u[:, end][1] - pi / 2endprob = BVProblem(simplependulum!, bc!, [pi / 2, pi / 2], tspan)sol = solve(prob, MIRK4(), dt = 0.05)\n\n\nFixed the BigFloat support issue for the Lobatto and Radau methods for BVP.\n\nMore TODOs:\nContinue the polishing of the simple COLDAE implementation and test the solver on more example problems to see if there are any bugs or improvements needed. File the pull request to get the COLDAE solver merged.\n\nContinuing the BigFloat support and getting the Lobatto and Radau solvers PR get merged as soon as possible.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"SDG 9th biweekly report","url":"/2024/08/30/24-sdg-9th/","content":"Review of the past two weeksIn the last two weeks, my work can be summarized as two parts: Refactoring the error estimation, mesh refinement routines for COLDAE solvers and helping with the Lobatto IIIa-IIIc and RadauIIa methods for BVPs.\n\nThe previous work focus on the implementation and refactorization of discretized nonlinear solving stuff to get the accurate numerical result of the nonlinear collocation system, although the error estimation and mesh refinement part is implemented before, they still need further polishment to fix the potential bugs. With the recent pushes in collocation equations solving, I started on actually completing this part of work.\n\nThe basic workflow of error estimation and mesh refinement procedures can be summarized as flow:\n# basic workflow# basic model specificationsmesh1, f, g, J, dg = probsol1 = nonlinear_solving(mesh1)adaptive &amp;&amp; returnmesh2 = halve_mesh(mesh1)if sol1.retcode == ReturnCode.Success\tsol2 = nonlinear_solving(mesh2) # solve on halved mesh\terr = error_estimate(sol1, sol2)\tif err &gt; abstol\t\t\tmesh3 = mesh_selector(cache)\t\t\tinfo = ReturnCode.Failure # Start again\tendelse\tif length(mesh1) &gt; max_num_subintervals\t\t\tinfo = ReturnCode.Failure\telse\t\t\thalve_mesh(mesh1)\t\t\tinfo = ReturnCode.Success # Restart\tendend\n\nIt is similar with what we are doing in MIRK methods defect estimation and mesh refinement, except that we use the comparison of two solutions in different mesh to estimate the error norm.\nNow the current implemented error estimate and mesh refinement routines are done, what’s left is the ForwardDiff stuff and sparse Jacobian configuation.\n\nHelped with the completion of LobattoIIIa-LobattoIIIc and RadauIIa solvers. Finally all the expanded and nested version of FIRK solvers are done now, although the CI still have some issues to be addressed, it will be good to go in a few days.\n\nWorking on replacing solution objects when we are evaluating boundary conditions, after this PR is done, all the API in MIRK methods and Shooting methods would be unified(and they always should be), they would be changed to the interpolation in the solution in boundary conditions:\n\n\nusing BoundaryValueDiffEqtspan = (0.0, pi / 2)function simplependulum!(du, u, p, t)    θ = u[1]    dθ = u[2]    du[1] = dθ    du[2] = -9.81 * sin(θ)endfunction bc!(residual, u, p, t)    residual[1] = u(pi/4)[1] + pi / 2    residual[2] = u(pi/2)[1] - pi / 2endprob = BVProblem(simplependulum!, bc!, [pi / 2, pi / 2], tspan)sol = solve(prob, MIRK4(), dt = 0.05)\n\nThis interpolation based indexing boundary conditions is better and we should change to this semantics long before😅.\nMore TODOs:\nRefactor the implemented solvers to be compatible with the SciML style, and simplify the internal of Lobatto DAE solvers. \n\nAddress the current issues in FIRK solvers.\n\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"2025 SDG 1st biweekly report","url":"/2025/08/15/25-sdg-1st/","content":"We were selected again by the NumFOCUS SDG grant🎉! With the new selection rules for the Small Development Grant program by NumFOCUS, the projects are now selected using a random script, it was a quite competitive round, but we are so lucky to be funded by NumFOCUS organization again for the project GPU-accelerated BVP Solvers. Firstly I should thank the NumFOCUS community for their generous support for the development of softwares for scientific computing. And I want to thank the PI Chris and the SciML community, for the cutting-edge scientific computing software development and warm support. The project will last 8 months, the main focus will be developing heterogenous and vendor-agnostic GPU accelerated boundary value problem solvers, for both collocation and shooting methods. The project will focus on using KernelAbstraction.jl to parallelize the collocation routines where the current implementation is a big for loop, so the generalization would make the computation much more faster with GPU parallelism. Actually the basic idea would come from the paper: Automated translation and accelerated solving of differential equations on multiple GPU platforms, which generalize the ODE solvers to hetergeneous GPU backend such as CUDA, Metal, OpenAPI and AMDGPU etc. Finally, I am really honored to get this funding to help me continue the BVP works. To make sure the project going on the right track with appropriate speed, I will record biweekly progress in this blog during the whole SDG project period.\nReview of the past two weeksIn the first two weeks, I continued the previous work on extension to dynamic optimization of BoundaryValueDiffEq.jl, including support inequality constraints and further application in optimal control problems, but the main issue remains is that the inequality constraints inn boundary value problems for example:\ntspan = (0.0, 1.0)function lotka_volterra!(du, u, p, t)    du[1] = 1.5 * u[1] - 1.0 * u[1] * u[2]    du[2] = -3.0 * u[2] + 1.0 * u[1] * u[2]endfunction bc!(residual, u, p, t)    residual[1] = u[1] - 1.0    residual[2] = u[2] - 1.0endprob = BVProblem(    lotka_volterra!, bc!, [4.0, 2.0], tspan, lcons = [0.0, 0.0], ucons = [Inf, Inf])sol = solve(prob, MIRK4(; optimizer = Ipopt.Optimizer()), dt = 0.05)\n\nthe inequality constraints over the whole time interval specifications would involve make every discrete elements on the whole time points to satisfy the constraints. \nTODOs in next two weeksIn the following two weeks, there are a few TODOs:\n\nContinue the privious PR and get that PR, Optimization based solvers merged ASAP.\nThe generalization to heterogeneous GPU backends for Shooting methods is relatively easy, the remain issue is the evaluation of boundary conditions routine, for example, if we have a boundary condition of:\n\nfunction bc!(residual, u, p, t)    residual[1] = u(pi / 4)[1] - 1.0    residual[2] = u(pi / 2)[1] - 1.0end\n\nWhich would always involves scalar indexing which is always disallowed by default. We need to figure out a better way to handling this.\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"2025 SDG 2nd biweekly report","url":"/2025/08/30/25-sdg-2nd/","content":"Review of the past two weeksDuring the last two weeks, I focused on the better integration of Optimization solvers for BVP problem solving in BoundaryValueDiffEq.jl. The basic funtionalities are done and the related PR, Optimization based solvers, is now mergable. What left in issue Onto Dynamic Optimization: Allow for solving via OptimizationProblem and allow inequality constraints is the interface for optimal control problems.\nA classical optimal control problem is the rocket launching problem(aka Goddard problem). Say we have a rocket with limited fuel and is launched vertically. And we want to control the final altitude of this rocket so that we can make the best of the fuel in rocket to get to the highest altitude. The state variables are:\n\nVelocity of the rocket: \nAltitude of the rocket: \nMass of the rocket and the fuel: \n\nThe control variable is\n\nThrust of the rocket: \n\nThe dynamics of the launching can be formulated with three differential equations:\n\nwhere the drag  is a function of altitude and velocity:\n\ngravity  is a function of altitude:\n\n is a constant. Suppose the final time is , we here want to maximize the , so the cost functional:\n\nSimilar solving for such optimal control problem can be found on JuMP.jl and InfiniteOpt.jl. The detailed parameters are taken from COPS.\nSo to model optimal control problems and solve them with BoundaryValueDiffEq.jl is like:\nusing BoundaryValueDiffEqMIRK, OptimizationMOI, Ipopth_0 = 1                      # Initial heightv_0 = 0                      # Initial velocitym_0 = 1.0                    # Initial massm_T = 0.6                    # Final massg_0 = 1                      # Gravity at the surfaceh_c = 500                    # Used for dragc = 0.5 * sqrt(g_0 * h_0)    # Thrust-to-fuel massD_c = 0.5 * 620 * m_0 / g_0  # Drag scalingu_t_max = 3.5 * g_0 * m_0    # Maximum thrustT_max = 0.2                  # Number of secondsT = 1_000                    # Number of time stepsΔt = 0.2 / T;                # Time per discretized steptspan = (0.0, 0.2)drag(x_h, x_v) = D_c * x_v^2 * exp(-h_c * (x_h - h_0) / h_0)g(x_h) = g_0 * (h_0 / x_h)^2function rocket_launch!(du, u, p, t)    # u_t is the control variable (thrust)    x_v, x_h, x_m, u_t = u[1], u[2], u[3], u[4]    du[1] = (u_t-drag(x_h, x_v))/x_m - g(x_h)    du[2] = x_v    du[3] = -u_t/cendfunction rocket_launch_bc!(res, u, p, t)    res[1] = u(0.0)[1] - v_0    res[2] = u(0.0)[2] - h_0    res[3] = u(0.0)[3] - m_0    res[4] = u(0.2)[4] - 0.0endfunction constraints!(res, u, p)    res[1] = u[1]    res[2] = u[2]    res[3] = u[3]    res[4] = u[4]endcost_fun(u, p) = -u[end-2] # To minimize, only temporary, need to use temporary solution here similar to what we do in boundary condition evaluations.#cost_fun(sol, p) = -sol(0.2)[4]u0 = [v_0, h_0, m_0, 0.0]rocket_launch_fun = BVPFunction(rocket_launch!, rocket_launch_bc!; cost = cost_fun, inequality = constraints!, bcresid_prototype = zeros(4))rocket_launch_prob = BVProblem(rocket_launch_fun, u0, tspan; lcons = [0.0, 0.0, m_T, 0.0], ucons = [Inf, Inf, m_0, u_t_max])sol = solve(rocket_launch_prob, MIRK4(; optimize = Ipopt.Optimizer()); dt = 0.002)\n\nThe basic idea is to formulate the optimal control problem as an unknown parameter estimation problem like we did in PR Add unknown parameters estimation. The control variables do not have dynamics attached to them, so their values can only be inferred by estimating with several constraints, e.g. boundary conditions, inequality constraints, equality constraints etc.\nTODOs in next two weeksIn the following two weeks, there are a few TODOs:\n\nMerge PR Optimization based solvers ASAP.\nFinalize the interface for optimal control problems.\nFinalize a suitable convention for the cost function in formulating optimal control problems, mainly about the interpolating and integral of control variables.\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"2025 SDG 3nd biweekly report","url":"/2025/09/15/25-sdg-3rd/","content":"Review of the past two weeksDuring the last two weeks, BoundaryValueDiffEq.jl finally support integration of Optimization solvers for BVP problem solving🎉🎉🎉! The basic funtionalities are done in PR Optimization based solvers and was merged several days ago. Now what left in issue Onto Dynamic Optimization: Allow for solving via OptimizationProblem and allow inequality constraints is the interface for optimal control problems. The development of optimal control interface will be complete in PR Optimal control interface.\nThe remain issues with the current optimal control interface PR is that the state variables and control variables are being passed in the problem construction simutanously, while the Jacobian and sparse pattern should only consider the state variables which has dynamics(f) attached to them, there is no way of specifying control variables during the Jacobian construction. So we may have to think another way to reformulate the structure of the constraints in OptimizationProblem and its Jacobian/sparsity pattern.\nTODOs in next two weeksIn the following two weeks, there are a few TODOs:\n\nFinalize the interface for optimal control problems, fix the state variables/control variables dilemma.\nFinalize a suitable convention for the cost function in formulating optimal control problems, mainly about the interpolating and integral of control variables.\n\n","categories":["SDG"],"tags":["SDG","BVP","Blog"]},{"title":"Compile MIRKDC on Ubuntu","url":"/2023/05/20/compile-mirkdc/","content":"Netlib is an online repository of various mathematical software, paper, and databases. This blog post record how to compile the MIRKDC, a Fortran routine capable of solving boundary value problems using MIRK methods with defect control and mesh refinement.\nCompileing environment:\n\nUbuntugfortranBLAS\n\nCompile BLASFirst, to successfully compile the programs, we need BLAS, a set of linear algebra routines we will need in MIRKDC. We can download BLAS from netlib. After downloading BLAS from netlib, yeah, we hae downloaded a compressed file .tgz. Then we need to unzip the BLAS routine and make install:\ntar -xvf blas-3.11.0.tgzcd BLAS-3.11.0/make\n\nAfter these commands, there would be a blas_LINUX.a file, that is what we need in the linking step.\nCompile and linkWe download the MIRKDC routine and its driver program, here, while the driver program is a txt file, we need to use the Fortran code section and name it as mirkdc_driver.f.\nMake sure all the three file, mirkdc.f, mirkdc_driver.f, blas_LINUX.a located in a same folder, then we can use gfortran to compile and link them:\ngfortran -o testing mirkdc.f mirkdc_driver.f -std=legacy blas_LINUX.a\n\nThe above code generate a testing file, then we can run the execuable file by:\n./testing\n\nHooray! Then we can specify our settings of the boundary value problem!\nSome notesHere, the MIRKDC routine and MIRKDC_driver routine are both Fortran77, which use a fixed-format. The fixed-format doesn’t allow writing any code in the first 6 column.(Free format doesn’t have this restriction) The first 6 column is only allowed to declare comments, declare a symbol which connent this line and the above line(Yeah, Fortran77 also restrict how many characters in one line😅, probably at that time, the coding machine couldn’t handle a line with too many characters).\n","categories":["Fortran"],"tags":["BVP","Blog","Fortran"]},{"title":"GSoC 10th week review","url":"/2023/08/06/gsoc-10th-week/","content":"During this week, I continued to improve BoundaryValueDiffEq.jl and help fix OrdinaryDiffEq.jl and relating docs. Here is a summary:\n\nCompleted the documentation for all of the avaiable methods in OrdinaryDiffEq.jl\nAdd MIRK3 method\nFix documentations for BoundaryValueDiffEq.jl\n[Finish all stage_limiter! and step_limiter! in explicit RK methods]\n\nNext week, I will follow Avik’s work on improving the performance and reducing precompile time of BoundaryValueDiffEq.jl, make BoundaryValueDiffEq.jl more powerful.\n","categories":["GSoC"],"tags":["BVP","Blog","GSoC"]},{"title":"GSoC 11th week review","url":"/2023/08/13/gsoc-11st-week/","content":"During this week, I focus on improving the basic infrastructure of BVP, mainly on fixing the BVPFunction PR, and updating the related docs.\nNext week, I will start the benchmarking job to test if the new MIRK methods behave well and continue to improve the internal of BoundaryValueDiffEq.jl.\n","categories":["GSoC"],"tags":["BVP","Blog","GSoC"]},{"title":"GSoC 12nd week review","url":"/2023/08/20/gsoc-12nd-week/","content":"This is the final week of GSoC 2023, what a fruitful and enjoyable journey!!!\nDuring this week, I focus on improving BoundaryValueDiffEq.jl usage, pushing the previous work on BVPFunction and fixing the initial guess interface. There are still some problems we need to note when we are constructing a BVPFunction, to avoid redundant memory usage and provide a clarifying API, I think maybe prob = BVProblem(BVPFunction(f, bc), u0, tspan) would be better than what we are already using, although there would involve many downstream errors in StochasticDiffEq.jl, I think this is relatively easy to fix.\nAt the same time, I helped maintain OrdinaryDiffEq.jl, fixed some issues on linear methods for ODEs\nCan’t believe this summer ended so quickly, it feels like it was just yesterday I received the GSoC successful selection email, but now, the GSoC final evaluation is around the corner. Next week, I will keep focusing on my previous PR and wrap up all of the work done during the whole summer.\n","categories":["GSoC"],"tags":["BVP","Blog","GSoC"]},{"title":"GSoC 1st week review","url":"/2023/06/04/gsoc-1st-week/","content":"To make sure the project going on the right track with appropriate speed, I will record every week’s progress in this blog during the whole summer.\nReview this weekIt is really exciting that GSoC has been a week, in the first week, I opened a PR to add the defect control adaptivity for BoundaryValueDiffEq.jl, this PR provides the basic structure of the defect control technique for BVP solving, the detailed explanation can be seen in another blog post. Although it is still working in progress and there are still some problems in the computing process, I debugged the WIP PR and fixed some errors, I think the basic working flow is almost done. I noticed Avik had some work on the purge NLsolve.jl with NonlinearSolve.jl, wish this modification will make the solving process more accurate and make the discrete stages for MIRK algorithms easy to use.\nWhile the previous blog post didn’t elaborate on the mesh refinement flow in detail, this week, I had a deeper look into the mesh refinement flow in MIRKDC, and here, I would like to record my understanding of how can we implement mesh refinement techniques in BoundaryValueDiffEq.jl and hopefully help me better understand the whole solving process.\nThe main mesh refinement part is located in the mesh_selector routine. First, we need to use the computed defect to generate mesh function values in the entire interval. The mesh function values of a subinterval can be computed using the below equation:\n\nThen we can set r1 as the maximum of mesh function values, r2 as the weighted sum of all mesh function values, r3 as the average of weighted mesh function values. We compare the maximum of mesh function values r1(aka test if r1 is not sufficiently large, which means the distribution of mesh function values is sufficiently uniform), here we use r1 &lt; rho*r3 to test r1 is not sufficiently large, if so, we halve the mesh. Otherwise(the mesh function values are sufficiently large, which means the distribution of mesh function values is sufficiently non-uniform), we redistribute a new mesh.\nif r1 &lt;= rho*r3    ###    mesh_new = half_mesh(mesh_current, n)    ###else    ###    mesh_new = redistribute(mesh_current, n, Nsub_star, s_hat)    ###end\n\nHalve meshHalving mesh simply divides the subinterval equally as two equal subintervals.\nfunction half_mesh(mesh_current::Vector, n::Int64)    mesh_new = zeros(Float64, 2 * n + 1)    mesh_new[1] = mesh_current[1]    for i in 1:n        mesh_new[2 * i + 1] = mesh_current[i + 1]        mesh_new[2 * i] = (mesh_current[i + 1] + mesh_current[i]) / 2.0    end    return mesh_newend\n\nRedistribute meshThe main idea of the mesh redistribution is to equidistribute the mesh function values.\nWe achieve the redistribution process by monitoring the total area under the mesh function Integral+Next_Piece, and comparing it with (the total area under the mesh function divided by Nsub_star(number of subintervals of the new mesh))\nThat is:\n\nwhile k &lt;= n    next_piece = s_hat[k] * (mesh_current[k + 1] - t)    if (integral + next_piece) &gt; zeta        mesh_new[i + 2] = (zeta - integral) / s_hat[k] + t        t = mesh_new[i + 2]        i = i + 1        integral = 0    else        integral = integral + next_piece        t = mesh_current[k + 1]        k = k + 1    endend\n\nThen we can get a new mesh with Nsub_star subintervals that satisfy our requirement.\n","categories":["GSoC"],"tags":["BVP","Blog","GSoC"]},{"title":"GSoC 2nd week review","url":"/2023/06/12/gsoc-2nd-week/","content":"This week, I continued to commit and fix errors in adaptive defect control PR, and now the PR is ready for review!\nWhen I was debugging the PR, I gradually noticed the importance of the nonlinear solving process in MIRK method, so I take a deep understanding of the special Newton iteration process in MIRKDC, here is a summary.\nNewton iteration in MIRKDCAfter the essential initialization, such as mesh, residual function and DE configuration, we use Newton iteration to solve the discrete system and get the discrete solution of the problem. However, the nonlinear system-solving routine in MIRKDC is quite different from what we have learned, what happened during this nonlinear equation-solving process? Here is a summary.\nWith the previous mesh and initialized discrete solution, we use the modified Newton method to solve the nonlinear system PHI(Y)=0 and get the solution approximation when the Newton correction is less than the tolerance newtol.\nTo begin the Newton iteration, we need to know that in the MIRKDC routine, we use a special Newton iteration to solve the nonlinear system. The modified Newton iteration routine, according to how well the iterates appear to be converging, can decide to use the damped Newton step or fixed Jacobian step to make iterate better converging.\nDamped newton stepWhen we are taking a damped Newton step, we choose a damping factor,  and provide a damped update to the current iterate , here,  is the Newton correction: , here  is the Jacobian in . By using the damped Newton step, the acceptability depends on if the damped Newton iterate produces a sufficient reduction to the natural criterion function. If the damped Newton step is successful, a fixed Jacobian step would be taken if this step is a full Newton step(to examine if ).\nFixed Jacobian stepThe core of the fixed Jacobian step is also to provide an update to the current iterate, but the fixed Jacobian step provides an update to the current iterate , here,  is the Newton correction: , but  is evaluated in at some previous iterates. By using the fixed Jacobian step, the acceptability depends on if the new iterate also produces a sufficient reduction to the natural criterion function. If the fixed Jacobian step is successful, the routine would try another fixed Jacobian step.\nWe need to note that the discrete stages k_discrete for the afterward computing are computed in the process of modified Newton iterations, it is a by-product while we solve the nonlinear equations. k_discrete has a size of , where s is the stage for the given MIRK method.\n","categories":["GSoC"],"tags":["BVP","Blog","GSoC"]},{"title":"GSoC 3rd week review","url":"/2023/06/18/gsoc-3rd-week/","content":"This week, I continued the previous work on adaptive defect control, now with the introduction of NonlinearSolve.jl, the structure of BoundaryVaueDiffEq.jl are becoming better.\nWhile there is some schoolwork this weekend, I didn’t put that much time into the project. I will be at home this Tuesday, so from then on, I can focus on GSoC again.\n","categories":["GSoC"],"tags":["BVP","Blog","GSoC"]},{"title":"GSoC 4th week review","url":"/2023/06/25/gsoc-4th-week/","content":"This week I continued the previous work on defect control adaptivity, and fixed errors in mesh_selector(stages summation etc.). In addition, I found the iteration process of collocation a little weird, so I opened another PR to fix this: Fix stage in collocation.\nDuring this week I also implemented all of the linear BVP test problems in the DiffEqProblemLibrary.jl, once the PR is merged and the BVProblemLibrary.jl is registered, I will continue adding the rest of the test problems, such as nonlinear test problems and many more.\nNext week, I will continue my work on defect control adaptivity, and try my best to solve the problem in defect_estimate(The defect estimation is too large) and make the code style more concise(remove redundant MIRK tableau, remove redundant coefficients etc.)\n","categories":["GSoC"],"tags":["BVP","Blog","GSoC"]},{"title":"GSoC 5th week review","url":"/2023/07/02/gsoc-5th-week/","content":"In this week, I continued the previous work on defect control adaptivity and added all of the BVP test problems and the others to the DiffEqProblemLibrary.jl, and closed the relating issue. All of the work in this week can be summarized as follows:\n\nFixed the indexing on discrete stages k_discrete and interpolation coefficients k_interp. The original indexing method for k_discrete and k_interp is awkward, by using a new matrix structure, we can directly use k_discrete[ith_subinterval, ith_stage] and k_interp[ith_subinterval, ith_stage] to addressing discrete stages and interpolantion coefficients.\nFixed the new stages and solution addition in the routine sum_stages. After we scaled the new stages using dt,  we need to add the new stages to the solution in the specific interval.\nAdd the nonlinear BVP test problems to DiffEqProblemLibrary.jl\nAdd the regular nonlinear BVP test problems to DiffEqProblemLibrary.jl\n\nNext week, I will continue to work on the problem that defect_norm is always bigger than the threshold, by comparing with the MIRKDC routine and monitoring the computing flow, while the other routines are the same, I think the problem lies in the collocation part.\n","categories":["GSoC"],"tags":["BVP","Blog","GSoC"]},{"title":"GSoC 6th week review","url":"/2023/07/09/gsoc-6th-week/","content":"This week, I complete the work on defect control adaptivity, the MIRK4 defect control workflow is working now. There are still some problems with MIRK6 method for now, but I think it will be figured out very soon.\nBesides, I also did some work on improving the bvp-solving ecosystem on SciML:\n\nImprove the initial guess of TwoPointBVProblem for BVP solving in SciMLBase.jl #462\nAdd the BVP test problems docstrings for DiffEqDocs.jl #677\n\n","categories":["GSoC"],"tags":["BVP","Blog","GSoC"]},{"title":"GSoC 7th week review","url":"/2023/07/16/gsoc-7th-week/","content":"During this week, besides preparing for the midterm evaluation, I implemented all of the MIRK methods in MIRKDC routine and have them all tested locally, including the 2nd, 3rd and improved methods etc., I will add them to BoundaryValueDiffEq.jl as soon as possible.\nBesides, I continued to refactor the defect control adaptivity PR, making the PR more compatible with the current SciML stack.\n","categories":["GSoC"],"tags":["BVP","Blog","GSoC"]},{"title":"GSoC 8th week review","url":"/2023/07/23/gsoc-8th-week/","content":"During this week, I continued to refactor the defect control adaptivity PR, and fixed the convergence tests for all of the MIRK methods. Once the defect control adaptivity PR is merged, I will focus on improving the performance of the current solvers.\n","categories":["GSoC"],"tags":["BVP","Blog","GSoC"]},{"title":"GSoC 9th week review","url":"/2023/07/30/gsoc-9th-week/","content":"JuliaCon week finally arrived!! It is so great to see the Julia user base growing!!!\nDuring this week, I continued to improve BoundaryValueDiffEq.jl, especially improving MIRKTableau and MIRKInterpTableau.\nBesides, I also fixed some bugs in DiffEqFlux.jl, replace the ADAM to Adam method, fixed the incorrect usage of _tspan in SciMLBase.jl. Also in the JuliaCon hackathon, I tried to revive the docs, but it seems there are still some problems we need to fix now.\n","categories":["GSoC"],"tags":["BVP","Blog","GSoC"]},{"title":"Adaptive MIRK BVP solvers - GSoC final report","url":"/2023/08/22/gsoc-final-report/","content":"In this Google Summer of Code 2023 project, I developed defect control adaptivity according to MIRKDC FORTRAN program for BoundaryValueDiffEq.jl and the related paper: Runge-Kutta Software with Defect Control for Boundary Value ODEs. After implementing the basic structure of defect control adaptivity, I focused on working on improving the user experience of BoundaryValueDiffEq.jl, and helped maintain OrdinaryDiffEq.jl.\nIt was a really fruitful summer, I would like to thank my mentors, Chris Rackauckas, Avik Pal and Yingbo Ma, it was their guidance that helped me complete my GSoC project.\nWhat was doneTo complete GSoC project, I broke down the whole project into three parts:\nDefect Control Adaptivity in MIRK MethodsThe detailed defect control adaptivity process can be simplified as: With the discrete solution we obtained from nonlinear solving, we first estimate the defect on a specific time interval. To estimate the defect on a subinterval, we need to evaluate the interpolation weights at sample points  and . After we get the interpolation weights, we need to set up the interpolations before defect estimation, basically, the interpolation setup flow is to prepare the extra stages for interpolation construction. After we get everything we need, we can proceed to construct the interpolant. We add the discrete solution, RK method stages(by-product during we evaluate  in the collocation process) and extra stages to construct the interpolant at two sample points. Then we can start to evaluate the defect during the whole period using the interpolant.\nTo evaluate the defect on each subinterval, we simply evaluate  and . As for the defect2 we have  and . Then the bigger estimated defect is the one we wanted.\nAfter we get the defect on the whole time interval, we can continue our computing, if the defect norm is bigger than the threshold(here, the threshold is predefined as 10%), it means the solution is not acceptable, we set the return code as Failure and start a mesh redistribution. If the defect norm is acceptable, we continue to compare the defect norm with our absolute tolerance, if the tolerance is satisfied, we get our final solution. But if the tolerance is not been satisfied, we need to construct a new mesh to equidistribute the defect and start the nonlinear solving and defect estimation process all over again.\nTo sum up, the core of the defect control adaptivity is we estimate the defect, and according to the defect, we decide whether we need to refine our mesh to achieve better accuracy. Just as described in New Interpolants for Asymptotically Correct Defect Control of BVODEs, the goal of defect control is to compute a numerical solution by adaptively choosing a mesh so that the maximum defect over the entire problem domain is bounded by a user-provided tolerance.\nTo experience the defect control adaptivity in BoundaryValueDiffEq, we can simply set adaptive = true when we solve our BVP in the solve function:\nusing BoundaryValueDiffEqfunction simplependulum!(du, u, p, t)    θ = u[1]    dθ = u[2]    du[1] = dθ    du[2] = -(g / L) * sin(θ)endfunction bc1!(residual, u, p, t)    residual[1] = u[1][1] + pi / 2    residual[2] = u[end][1] - pi / 2endL = 1.0const g = 9.81tspan = (0.0, pi / 2)bvp=BVProblem(simplependulum!,bc1!,[0.0, 0.0],tspan)sol = solve(bvp, MIRK4(), adaptive = true)\n\nImprove the internals of BoundaryValueDiffEq.jlWith several new MIRK methods being developed for BoundaryValueDiffEq.jl, the plan for the near future is to optimize the internals of BoundaryValueDiffEq.jl, for details we can refer to More TODOs\nEnhance the BVP ecosystem in SciMLBesides the adaptivity work, I implemented the standard test problems for BVP solvers and worked on the SciMLBase.jl, improving the user experience of BVP solvers, including fixing initial guesses, and specific functions for BVP and many more.\nDetailed PRsBoundaryValueDiffEq.jl\n\n\nDescription\nStatus\n\n\n\nAdd MIRK6 method\nMerged\n\n\nAdd defect control adaptivity\nMerged\n\n\nFix stage in collocation\nMerged\n\n\nAdd MIRK5 method\nMerged\n\n\nrefactor: Fix MIRKTableau and MIRKInterpTableau\nMerged\n\n\nAdd MIRK3 method\nMerged\n\n\nUpdate README\nMerged\n\n\nUpdate docs for solvers\nMerged\n\n\nAdd MIRK2 method\nMerged\n\n\nFix initial guess interface\nMerged\n\n\nOrdinaryDiffEq.jl\n\n\nDescription\nStatus\n\n\n\nImplement DPRKN5 method\nMerged\n\n\nAdd ERKN7 method\nMerged\n\n\nAdd more optional threading\nMerged\n\n\nRemove unnecessary branches of Vern7, Vern9 and Tsit5\nMerged\n\n\nAdd docs for optional threading\nMerged\n\n\nAdd DPRKN4 method\nMerged\n\n\nAdd DPRKN6FM method\nMerged\n\n\nThrow error when using partitioned ODE methods with ODEProblem\nMerged\n\n\nAdd MSRK54 method\nMerged\n\n\nAdd MSRK6 method\nMerged\n\n\nAdd ESDIRK436L2SA2 method\nMerged\n\n\nAdd CONTRIBUTING.md\nMerged\n\n\nAdd ESDIRK437L2SA method\nMerged\n\n\nAdd ESDIRK547L2SA2\nMerged\n\n\nAdd SIR54 method\nMerged\n\n\nAdd CG4a method\nMerged\n\n\nAdd missing methods to docs\nMerged\n\n\nFinish all stage_limiter! and step_limiter!\nMerged\n\n\nChange exp to exponential! in linear methods\nMerged\n\n\nSciMLBase.jl\n\n\nDescription\nStatus\n\n\n\nAdd isinplace checks for DDEFunction\nMerged\n\n\nAdd BVPFunction\nMerged\n\n\nThrow appropriate error when analytic is not given\nMerged\n\n\nImprove initial guess for TwoPointBVProblem\nMerged\n\n\nFix promoted tspan for BVProblem and ODEProblem\nMerged\n\n\nDiffEqDocs.jl\n\n\nDescription\nStatus\n\n\n\nFix DiffEqDevDocs broken link\nMerged\n\n\nAdd docs for DPRKN5 and ERKN7\nMerged\n\n\nAdd docs for DPRKN4 and DPRKN6FM\nMerged\n\n\nAdd docs for MSRK 5, 6 and Stepanov5 methods\nMerged\n\n\nAdd DiscreteFunctionExpr, DiscreteProblemExpr and docs\nMerged\n\n\nAdd docs for new ESDIRK methods\nMerged\n\n\nAdd docs for SIR54, CG4a and Alshina methods\nMerged\n\n\nUpdate BVP tutorial\nMerged\n\n\nAdd BVP test problems docs\nMerged\n\n\nFix BVProblemLibrary docs\nMerged\n\n\nUpdate BVP docs\nMerged\n\n\nDiffEqProblemLibrary.jl\n\n\nDescription\nStatus\n\n\n\nAdd BVProblemLibrary\nMerged\n\n\nAdd nonlinear BVP test problems\nMerged\n\n\nAdd the rest BVP test problems\nMerged\n\n\nOther repos\n\n\nDescription\nStatus\n\n\n\nAdd DiscreteFunction\nMerged\n\n\nAdd transistor amplifier DAE problem\nMerged\n\n\nRevive docs\nMerged\n\n\nReplace ADAM with Adam etc\nMerged\n\n\nFix TrustRegion docstring\nMerged\n\n\nWeekly ReportsThese are the weekly reports that I recorded during GSoC period:\n\n\n\nWeek\nLink\n\n\n\nWeek1:\nhttps://erikqqy.github.io/2023/06/04/gsoc-1st-week/\n\n\nWeek2:\nhttps://erikqqy.github.io/2023/06/11/gsoc-2nd-week/\n\n\nWeek3:\nhttps://erikqqy.github.io/2023/06/18/gsoc-3rd-week/\n\n\nWeek4:\nhttps://erikqqy.github.io/2023/06/25/gsoc-4th-week/\n\n\nWeek5:\nhttps://erikqqy.github.io/2023/07/02/gsoc-5th-week/\n\n\nWeek6:\nhttps://erikqqy.github.io/2023/07/09/gsoc-6th-week/\n\n\nWeek7:\nhttps://erikqqy.github.io/2023/07/16/gsoc-7th-week/\n\n\nWeek8:\nhttps://erikqqy.github.io/2023/07/23/gsoc-8th-week/\n\n\nWeek9:\nhttps://erikqqy.github.io/2023/07/30/gsoc-9th-week/\n\n\nWeek10:\nhttps://erikqqy.github.io/2023/08/06/gsoc-10th-week/\n\n\nWeek11:\nhttps://erikqqy.github.io/2023/08/13/gsoc-11st-week/\n\n\nWeek12:\nhttps://erikqqy.github.io/2023/08/20/gsoc-12nd-week/\n\n\nFuture WorkI will continue to maintain and improve BoundaryValueDiffEq.jl and other DiffEq packages in the future, help implement more algorithms and make the internal of BoundaryValueDiffEq.jl much more robust.\nNeuralBVPWith the recent development of BoundaryValueDiffEq.jl, especially the type stability and performance enhancement and defect control adaptivity, the BVP solving stack in SciML is growing stronger, We can now utilize BoundaryValueDiffEq.jl to help research NeuralBVP and related topics.\nMore BVP-related solversRight now, there are only MIRK method and shooting method in BoundaryValueDiffEq.jl, while FORTRAN has many other solvers like COLDAE to solve BVP-DAE, MUSL and MUSN to perform multiple-shooting methods on BVP, we should add those methods to BoundaryValueDiffEq.jl as well.\nBenchmarks on existing solversWith the recent development in BoundaryValueDiffEq.jl, we need a comprehensive comparison of current solvers in Julia, FORTRAN and MATLAB.\nOptimize the current MIRK Methods and AdaptivityAlthough for now, the BVP solving is much better than before, there are still a lot of things we can push forward. The first is the new algorithms for solving BVP-related stuff, including but not limited to BVP-DAE solving, multiple shooting etc.\nThere is still a long way to go to establish a comprehensive and competitive BVP solvers library, but I believe with our joint effort, the BoundaryValueDiffEq.jl  and SciML ecosystem will grow more and more powerful!\nAcknowledgementIt was a great opportunity to be part of an inspiring community, many thanks to my mentors Chris Rackauckas, Avik Pal and Yingbo Ma. And finally thanks GSoC community and NumFOCUS community for their support.\n","categories":["GSoC"],"tags":["BVP","Blog","GSoC"]},{"title":"Hello World","url":"/2023/05/13/hello-world/","content":"终于重新搭建起了自己的博客！想起在大二的时候自己搭的就博客，好像当时用的是yilia主题，为了mathjax插件头疼了好几天，最终还是放弃了🤣。原来的博客已经吃灰了将近两年的时间，希望自己可以将这个博客坚持做下去，坚持记录与输出！\n\n\n本博客采用的是hexo博客，使用的主题是theme keep，部署到了GitHub上并采用GitHub actions自动部署。\n","categories":["Hello"],"tags":["Blog","Hello","Hexo"]},{"title":"Kick start of GSoC!","url":"/2023/05/29/preparation/","content":"I was very fortunate to be selected for this year’s SciML GSoC under NumFOCUS umbrella, a big thank you to my mentor Chris, Yingbo and Avik for letting me have this opportunity!!!\nIt has been a month so far, what have I been doing these days? Here is a summary.\nUnderstand and compile MIRKDC programAfter I finished my graduation project and thesis, I immediately started to understand the MIRKDC program, I learned the basic structure of MIRKDC and got the solver and driver programs running on my computer:\ngfortran -o testing mirkdc.f mirkdc_driver.f -std=legacy blas_LINUX.a./testing\n\nThen we can see an interactive prompt where we can specify which method we want to use and the parameters of the given “Swirling flow III” problem.[^1]  More details can be found in this blog post: https://erikqqy.github.io/2023/05/20/compile-mirkdc/\n\nDevelop defect control in BoundaryValueDiffEq.jlBesides, I also tried to add a defect control routine to BoundaryValueDiffEq.jl. Right now, the basic structure is done, relating PR is here and the main flow can be summarized in a short description:\n\nWe compute the defect estimation in the whole interval, and generate new mesh to dimish the defect to get more accurate solution.\n\nThe detailed computation flow is depicted as follows:\nBased on the discrete solution we already got using NLsolve.jl and MIRK tableau, \nopt = isa(prob.problem_type, TwoPointBVProblem) ?            alg.nlsolve(ConstructJacobian(jac_wrapper, vec_y), vec_y) :            alg.nlsolve(ConstructJacobian(jac_wrapper, S, vec_y), vec_y)nest_vector!(S.y, opt[1])\n\nWe can evaluate the weight polynomials(algorithm-dependent) at two sample points  and  to get the weights and their first derivatives by interp_weights. Then in every subinterval, we use interp_setup to compute the new stages in k_interp to prepare the construction of interpolants. We add the discrete solution, weights, weights derivative, discrete stages stored in k_discrete and additional stages stored in k_interp to evaluate the interpolant and compute the defect estimation in each subinterval. After we get the defect of the entire interval, we compute the defect norm simply by defect_norm = maximum(abs.(defect)). Then we estimate whether the defect_norm is bigger than the threshold(here, we set this threshold as 10%) and the tolerance.\nAfter the estimation of the defect, all we need to do is to decide whether we need to refine the mesh by half_mesh(divide the original subinterval as two equal subintervals) or redistribute(generate a new mesh according to the defect on each subinterval to diminish the defect on each subinterval), this process takes place in mesh_selector.  After the new mesh is generated, we restart the above process and reestimate the defect until the defect estimation is lower than the tolerance.\nThe detailed working flow can be visualized in the diagram below:\n\nSome things unclearBut there is still something I am unclear about. The most important one is the discrete stages of MIRK method in the entire interval, aka k_discrete. I know that in the MIRKDC routine, the discrete stages for MIRK method are computed in the process of computing PHI, which is the value of the residual function on each subinterval. This process has a correspondence part in BoundaryValueDiffEq.jl, that is the Φ! and update_K! part, where we update K in MIRK4GeneralCache during the nonlinear solving process.\nstruct MIRK4GeneralCache{kType} &lt;: GeneralMIRKCache    K::kTypeend\n\nfunction Φ!(S::BVPSystem{T}, TU::MIRKTableau, cache::AbstractMIRKCache) where {T}    ####    for i in 1:(N-1)        update_K!(S, cache, TU, i, h)    end    ####end\n\nWhere the update_K! is defined as:\nfunction update_K!(S::BVPSystem, cache::AbstractMIRKCache, TU::MIRKTableau, i, h)    M, N, residual, x, y, fun!, order = S.M, S.N, S.residual, S.x, S.y, S.fun!, S.order    K, b = cache.K, TU.b    c, v, X = TU.c, TU.v, TU.x    function Kᵣ!(Kr, y, y₁, r)        x_new = x[i] + c[r] * h        y_new = (1 - v[r]) * y + v[r] * y₁        if r &gt; 1            y_new += h * sum(j -&gt; X[r, j] * K[j], 1:(r - 1))        end        fun!(Kr, y_new, S.p, x_new)    end    for r in 1:order        Kᵣ!(K[r], y[i], y[i + 1], r)    endend\n\nWhile I built the basic structure, there are still some things that haunted me for a long time. When I want to assemble all of the discrete stages K in all of the subintervals, the iteration seems weird, what I finally got is a Vector{Vector} which stored the same vector components. (And after the nonlinear solving process, the value of cache.K only stored the discrete stage in the last subinterval)\nReferences\nAscher, Mattheij, and Russell, “Numerical Solution of Boundary Value Problems for Ordinary Differential Equations”, Classics in Applied Mathematics Series, Society for Industrial and Applied Mathematics, Philadelphia, 1995\n","categories":["GSoC"],"tags":["BVP","Blog","GSoC"]}]